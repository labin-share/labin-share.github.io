<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="分布式锁-redis实现"><meta name="keywords" content="redis,分布式锁"><meta name="author" content="Labin"><meta name="copyright" content="Labin"><title>分布式锁-redis实现 | Labin博客分享</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-利用set命令"><span class="toc-text">1.  利用set命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-例子"><span class="toc-text">1.1 例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-优缺点"><span class="toc-text">1.2 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-利用RedLock"><span class="toc-text">2. 利用RedLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-例子"><span class="toc-text">2.1 例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-RedLock的不足之处"><span class="toc-text">2.2 RedLock的不足之处</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/labin-share/labin-share.github.io/master/img/avatar.png"></div><div class="author-info__name text-center">Labin</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Labin博客分享</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">分布式锁-redis实现</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-14</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a href="http://www.redis.cn/topics/distlock.html" target="_blank" rel="noopener">redis 官网关于distributed lock的讨论</a></p>
<p>redis分布式锁有多种实现方式。</p>
<ul>
<li>利用set命令</li>
<li>RedLock</li>
<li>Redission</li>
</ul>
<h2 id="1-利用set命令"><a href="#1-利用set命令" class="headerlink" title="1.  利用set命令"></a>1.  利用set命令</h2><p>主要是利用了NX参数，只有当key不存在的时候，不会被重新设置。</p>
<p>比如，使用以下指令设置mykey，并且过期时间是5秒，只有mykey不存在的时候才会创建成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set mykey 1 EX 5 NX</span><br></pre></td></tr></table></figure>

<p>所以第一次执行的结果会是“ok”，在5秒内再次执行将不会执行成功，返回“nil”。</p>
<p>所以可以利用该特性，设计成分布式锁</p>
<ul>
<li>用key当成锁</li>
<li>value为进程唯一的识别</li>
<li>过期时间为占用锁的时间</li>
</ul>
<p>注意这里的value应该是唯一值。每个进程应该是不同的value，解锁的时候需要用到，避免释放了其他进程所设置的锁。解锁过程如下<br>编写lua脚本</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>, <span class="string">"mykey"</span>) == <span class="string">"test"</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,<span class="string">"mykey"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>该脚本表示在删除mykey之前，即解锁之前，判断锁是否为本进程设置的value，如果是则可以删除，否则不可以删除，避免删除了其他进程设置的锁。</p>
<p>然后执行lua脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.99.100 -p 6379 --eval unlock.lua</span><br></pre></td></tr></table></figure>

<p>如果用的是docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -v /development:/development redis redis-cli  -h 192.168.99.100 -p 6379 --eval /development /docker/redis/unlock.lua</span><br></pre></td></tr></table></figure>

<p>按照这种方式，可以在java中使用jedis实现</p>
<h3 id="1-1-例子"><a href="#1-1-例子" class="headerlink" title="1.1 例子"></a>1.1 例子</h3><p>看下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTest</span> </span>&#123;</span><br><span class="line">    Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialRedissonConn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jedis = <span class="keyword">new</span> Jedis(<span class="string">"docker.host.ip"</span>,<span class="number">6379</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOneLockKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jedis.set(<span class="string">"mykey"</span>,<span class="string">"processOne"</span>,<span class="string">"NX"</span>,<span class="string">"EX"</span>,<span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">"processOne lock key"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTwoLockKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = jedis.set(<span class="string">"mykey"</span>, <span class="string">"processTwo"</span>, <span class="string">"NX"</span>, <span class="string">"EX"</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">if</span>(result!=<span class="keyword">null</span>&amp;&amp;result.equalsIgnoreCase(<span class="string">"ok"</span>))</span><br><span class="line">            System.out.println(<span class="string">"processTwo lock key"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"processTwo wait key."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOneUnlockKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String luaScript =</span><br><span class="line">                <span class="string">"if redis.call(\"get\", KEYS[1]) == ARGV[1] then\n"</span> +</span><br><span class="line">                        <span class="string">"    return redis.call(\"del\",KEYS[1])\n"</span> +</span><br><span class="line">                        <span class="string">"else\n"</span> +</span><br><span class="line">                        <span class="string">"    return 0\n"</span> +</span><br><span class="line">                        <span class="string">"end"</span>;</span><br><span class="line">        jedis.eval(luaScript, <span class="number">1</span>, <span class="string">"mykey"</span>, <span class="string">"processOne"</span>);</span><br><span class="line">        System.out.println(<span class="string">"processOne unlock key"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSynchronizedTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        processOneLockKey();</span><br><span class="line">        processTwoLockKey();</span><br><span class="line"></span><br><span class="line">        processOneUnlockKey();</span><br><span class="line">        processTwoLockKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Before 方法初始化了redis的连接。</p>
<p>processSynchronizedTest 用于模拟两个进程获取锁时互斥的情况。</p>
<ol>
<li>首先调用processOneLockKey, 模拟进程processOne <em>(实际上这里的并没有开启另外一个进程，实际应用场景中，应该是一个新的JVM进程或者是其他服务节点)</em> 获取锁的情况。processOne用唯一的value “processOne” 获取到名为mykey的锁。</li>
<li>processTwoLockKey 是模拟进程processTwo获取同样的锁，但是该锁已经被占，获取不到。</li>
<li>processOneUnlockKey 模拟processOne解锁的过程。通过调用lua脚本，先判断mykey锁是不是被自己占用，通过判断value值是否是processOne即可知道。如果是，删除掉锁。</li>
<li>再次调用 processTwoLockKey 获取锁，因为锁已经被释放了，所以成功获取。</li>
</ol>
<p>注意，这里要使用lua脚本的原因是，lua脚本能够保证原子性操作，即检查和解锁这组操作时原子性的。作用跟redis multi一样，但是这里还有个好处是，只需要连接一次redis，一次性传输所有指令。</p>
<h3 id="1-2-优缺点"><a href="#1-2-优缺点" class="headerlink" title="1.2 优缺点"></a>1.2 优缺点</h3><p>利用set指令实现的分布式锁优缺点：</p>
<ol>
<li>好处是简单容易实现。</li>
<li>缺点是<ul>
<li>只能用于单个redis实例的场景。如果是主从模式，假设process one在主节点中获取锁，后面主节点挂掉，从节点开始代替主节点，这时候从节点没有锁，process two获取锁成功，将会导致锁的作用失效。</li>
<li>缓存如果设置了过期时间，那么在一些情况下，如果程序进入阻塞状态，导致超过了时间，这时候锁已经释放，而程序恢复执行，就会造成错误。</li>
<li>如果不设置过期时间，当一个线程获得锁之后，由于一些特殊原因挂掉，那么锁将永远无法释放。</li>
</ul>
</li>
</ol>
<h2 id="2-利用RedLock"><a href="#2-利用RedLock" class="headerlink" title="2. 利用RedLock"></a>2. 利用RedLock</h2><p>RedLock是可以在多个redis实例中可以同步进程的同步锁算法。</p>
<p>RedLock是为了解决利用set实现锁的方案的时不适用于多个redis实例的情况。</p>
<p>它的实现过程是：</p>
<ol>
<li>客户端获取当前的unix时间，以毫秒为单位。</li>
<li>假设有N个redis server，则客户端使用相同的key和相同的value，向所有的redis实例发出获取锁的指令。</li>
<li>在获取锁的时候，如果在某个redis实例时间超出了客户端所设置的最大等待时间，那么会认为时获取锁不成功的，客户端会直接向所有redis实例发出释放锁的指令 <em>（因为有可能在某些redis实例上获得锁了，但是返回的时候可能网络问题超时等等，造成客户端以为获取锁不成功，实际上在redis server上已经成功了）</em>。</li>
<li>如果在获取锁的期间，在某个redis上获取锁失败 <em>（指的是无法正常连上redis server或者有异常的情况）</em>， 则客户端也会主动的释放所有的锁。</li>
<li>只要客户端获取的锁，占有半数以上，即N/2+1以上，就认为获取锁成功。因为在客户端获取锁的期间，其他的客户端也在以相同的方式在获取，所以有可能有些redis server上的锁已经被其他客户端占着。</li>
</ol>
<p>RedLock算法实际上的有效时间：<br>在客户端看来，当成功获取了所有redis server上的锁之后，锁上面的有效时间应该不是一样的。原因有两个：</p>
<ol>
<li>客户端在获取锁的时候，需要遍历所有的redis实例，所以获取每个redis server锁的时间应该是有差别的。</li>
<li>每个redis server上的时间存在着时钟漂移的现象。</li>
</ol>
<p>所以实际上客户端获得所有锁之后，锁的有效时间应该是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最小有效时间 = TTL - (T2-T1) - CLOCK_DRIFT</span><br></pre></td></tr></table></figure>

<p>其中TTL是客户端自己设置的有效时间， T1是指获取到第一个redis server上的锁的时间，T2表示获取到最后一个redis server的时间， CLOCK_DRIFT表示时钟漂移。</p>
<h3 id="2-1-例子"><a href="#2-1-例子" class="headerlink" title="2.1 例子"></a>2.1 例子</h3><p>引入redisson依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.RedissonRedLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redLockTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; redisPort = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        redisPort.add(<span class="number">6379</span>);</span><br><span class="line">        redisPort.add(<span class="number">6380</span>);</span><br><span class="line">        redisPort.add(<span class="number">6381</span>);</span><br><span class="line">        redisPort.add(<span class="number">6382</span>);</span><br><span class="line">        List&lt;RedissonClient&gt; redissonClients = initialRedissionClients(redisPort);</span><br><span class="line">        List&lt;RLock&gt; rLocks = initialLockForRedis(redissonClients);</span><br><span class="line">        RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(rLocks.get(<span class="number">0</span>),rLocks.get(<span class="number">1</span>),rLocks.get(<span class="number">2</span>),rLocks.get(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">boolean</span> isLock = redLock.tryLock(<span class="number">500</span>, <span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Got locks successfully."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;RedissonClient&gt; <span class="title">initialRedissionClients</span><span class="params">(List&lt;Integer&gt; redisPorts)</span></span>&#123;</span><br><span class="line">        Config config;</span><br><span class="line">        List&lt;RedissonClient&gt; redissonClients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer port : redisPorts)&#123;</span><br><span class="line">            config = <span class="keyword">new</span> Config();</span><br><span class="line">            config.useSingleServer().setAddress(<span class="string">"redis://docker.host.ip:"</span>+port);</span><br><span class="line">            redissonClients.add(Redisson.create(config));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redissonClients;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;RLock&gt; <span class="title">initialLockForRedis</span><span class="params">(List&lt;RedissonClient&gt; redissonClients)</span></span>&#123;</span><br><span class="line">        String resourceName = <span class="string">"REDLOCK_KEY"</span>;</span><br><span class="line">        List&lt;RLock&gt; rLocks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(RedissonClient redissonClient:redissonClients)&#123;</span><br><span class="line">            rLocks.add(redissonClient.getLock(resourceName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rLocks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有四个redis端口，这些端口对应的是redis实例，也就是总共有四个redis实例。为了方便，全都是用docker在同一台机器上启动的，只是端口不同。</p>
<p>首先调用initialRedissionClients连接到四台redis server，并且实例化对应的redisson client。</p>
<p>再调用initialLockForRedis初始化每一台redis server的锁，得到List<rlock> rLocks。这一步只是初始化，还没有真正的去获取锁。并且用这些锁实例rLocks去实例化RedLock。</rlock></p>
<p>然后再调用redLock.tryLock去真正的到每台redis上获取锁。这里指定了最大响应时间和有效时间。</p>
<p>正常应该会看到输出提示已经成功获取到锁。并且查看redis server，可以看到下面的结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> redis server1</span><br><span class="line">192.168.99.100:6379&gt; hgetall REDLOCK_KEY</span><br><span class="line">1) "f5e330c5-8cea-4ad3-b3bd-9957b6c94b8f:1"</span><br><span class="line">2) "1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> redis server2</span><br><span class="line">192.168.99.100:6380&gt; hgetall REDLOCK_KEY</span><br><span class="line">1) "febff720-0d5c-45d3-af3f-14ce12596e00:1"</span><br><span class="line">2) "1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> redis server3</span><br><span class="line">192.168.99.100:6381&gt; hgetall REDLOCK_KEY</span><br><span class="line">1) "cb3faf66-61d3-4de0-ac66-b60efa16a012:1"</span><br><span class="line">2) "1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> redis server4</span><br><span class="line">192.168.99.100:6382&gt; hgetall REDLOCK_KEY</span><br><span class="line">1) "9d47d24a-b89e-4395-a0d5-d22e8a651e6e:1"</span><br><span class="line">2) "1"</span><br></pre></td></tr></table></figure>

<p>redlock设置的是一个hash值，第一个值是上面每个RLock对应的uuid+线程id。第二个值表示重入的次数，如果客户端多次重入锁，这个值将会发生变化。</p>
<p>如果要模拟获取锁失败的情况，可以在获取锁的期间，停掉某台redis server，这时候因为在获取锁的时候连不上这台server，将会导致整个获取锁的过程失败。redis server中将不会看到REDLOCK_KEY。</p>
<p>如果要模拟获取锁的数目大于N/2+1时，也就是不必全部都获得锁，即为获取锁成功的情况，可以先在其中一台server设置上设置REDLOCK_KEY。比如在6379这台server上，先认为设置REDLOCK_KEY，然后再执行程序。这样客户端再获取锁的时候，因为6379这台server上已经有REDLOCK_KEY存在，无法占用这个锁，只能取得其他另外三台server的锁，这时候还是大于N/2+1的情况，所以还是成功的获得锁。</p>
<h3 id="2-2-RedLock的不足之处"><a href="#2-2-RedLock的不足之处" class="headerlink" title="2.2 RedLock的不足之处"></a>2.2 RedLock的不足之处</h3><p><a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">redlock的不足之处讨论 Martin Kleppmann</a></p>
<p>RedLock 不能完全保证正确性，其根本原因出现在RedLock的锁有过期时间的概念。</p>
<p>由于系统本身有阻塞，调度，系统时间阶跃的问题，会对过期时间产生一些预期之外的事情：</p>
<ol>
<li>获得锁之后，客户端在执行任务的期间，有可能会发生阻塞或者系统本身的调度<ul>
<li>如果在阻塞挂起期间，锁已经过时，然后任务恢复运行并没有感知锁已经过时，继续执行任务，将会发生错误。</li>
</ul>
</li>
<li>系统时间阶跃的问题<ul>
<li>系统阶跃问题指的是，系统的时间可能发生不连续的跳跃，可能会向前也可能会向后。而redis的过期时间是基于系统时间的，如果向前跳跃，可能锁的过期时间会因此而较早结束。</li>
<li>基于上面的原因，假设有A,B,C三个redis server，本来客户端1已经从A，B获得了锁，但是因为时间阶跃的问题，导致B早些过时，导致B，C是无锁的状态，那么另外一个进程就可以从这两个redis server获得锁，导致系统同时存在客户端1和客户端2同时拥有锁，在执行任务的状态。</li>
</ul>
</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Labin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/posts/分布式/分布式锁/distributed-lock-redis/">http://yoursite.com/posts/分布式/分布式锁/distributed-lock-redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a><a class="post-meta__tags" href="/tags/分布式锁/">分布式锁</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/posts/解决方案/登录验证/"><i class="fa fa-chevron-left">  </i><span>登录验证</span></a></div><div class="next-post pull-right"><a href="/posts/分布式/分布式锁/distributed-lock-zookeeper/"><span>分布式锁-zookeeper实现</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 By Labin</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>